package ciphers

import (
	"encoding/hex"
	"fmt"
	"strconv"
)

var cipherListOrder = [][]byte{
	{0x00, 0x04}, {0x00, 0x05}, {0x00, 0x07}, {0x00, 0x0a}, {0x00, 0x16}, {0x00, 0x2f}, {0x00, 0x33}, {0x00, 0x35},
	{0x00, 0x39}, {0x00, 0x3c}, {0x00, 0x3d}, {0x00, 0x41}, {0x00, 0x45}, {0x00, 0x67}, {0x00, 0x6b}, {0x00, 0x84},
	{0x00, 0x88}, {0x00, 0x9a}, {0x00, 0x9c}, {0x00, 0x9d}, {0x00, 0x9e}, {0x00, 0x9f}, {0x00, 0xba}, {0x00, 0xbe},
	{0x00, 0xc0}, {0x00, 0xc4}, {0xc0, 0x07}, {0xc0, 0x08}, {0xc0, 0x09}, {0xc0, 0x0a}, {0xc0, 0x11}, {0xc0, 0x12},
	{0xc0, 0x13}, {0xc0, 0x14}, {0xc0, 0x23}, {0xc0, 0x24}, {0xc0, 0x27}, {0xc0, 0x28}, {0xc0, 0x2b}, {0xc0, 0x2c},
	{0xc0, 0x2f}, {0xc0, 0x30}, {0xc0, 0x60}, {0xc0, 0x61}, {0xc0, 0x72}, {0xc0, 0x73}, {0xc0, 0x76}, {0xc0, 0x77},
	{0xc0, 0x9c}, {0xc0, 0x9d}, {0xc0, 0x9e}, {0xc0, 0x9f}, {0xc0, 0xa0}, {0xc0, 0xa1}, {0xc0, 0xa2}, {0xc0, 0xa3},
	{0xc0, 0xac}, {0xc0, 0xad}, {0xc0, 0xae}, {0xc0, 0xaf}, {0xcc, 0x13}, {0xcc, 0x14}, {0xcc, 0xa8}, {0xcc, 0xa9},
	{0x13, 0x01}, {0x13, 0x02}, {0x13, 0x03}, {0x13, 0x04}, {0x13, 0x05},
}

// ExtractCipherBytes converts a selected cipher to an index of the known cipher list
func ExtractCipherBytes(c string) string {
	if c == "" {
		return "00"
	}
	count := 1
	for _, cipher := range cipherListOrder {
		if hex.EncodeToString(cipher) == c {
			break
		}
		count = count + 1
	}
	return fmt.Sprintf("%.2x", count)
}

// ExtractVersionByte returns 1-byte hex string representing the negotiated version
func ExtractVersionByte(c string) string {
	if c == "" || len(c) < 4 {
		return "0"
	}
	ival, err := strconv.Atoi(c[3:4])
	if err != nil {
		return "0"
	}
	return string(byte(0x61 + ival))
}
